{"version":3,"sources":["russiandoll.es","russiandoll-1.0.0.min.js"],"names":["RussianDoll","source","_","isString","TypeError","errorMessages","sourceMustBeString","this","tokens","tokenizer","html","parser","unmatchedCurlyBrackets","paragraphInFragment","regExps","elements","curlyBrackets","paragraph","fragmentLink","matches","fragmentOpen","fragmentClose","tags","strikethrough","bold","italic","image","link","safeStr","str","test","kebabCase","deburr","escape","markup","replace","size","match","SyntaxError","map","compact","flatten","split","lastIds","level","result","reduce","output","token","i","each","clone","v","k","lastIndex","exec","openedBy","id","first","last","shift","push","pop","undefined","uniqueId","length"],"mappings":"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","file":"russiandoll-1.0.0.min.js","sourcesContent":["\"use strict\";\n\nconst errorMessages = {\n  sourceMustBeString:     \"Source must be a string\",\n  unmatchedCurlyBrackets: \"Unmatched curly brackets {}\",\n  paragraphInFragment:    \"Cannot nest a paragraph inside a fragment\"\n};\n\nconst regExps = {\n  elements: {\n    curlyBrackets:  /(\\{(?:[A-z\\u00C0-\\u00ff\\d-_']+\\:)?|\\})/,\n    paragraph:      /(\\>[A-z\\u00C0-\\u00ff\\d-_']*)\\s?/g,\n    fragmentLink:   /(\\[[^\\]]*\\](?:#[A-z\\u00C0-\\u00ff\\d-_']+)?)/g\n  },\n  matches: {\n    paragraph:      /\\>([A-z\\u00C0-\\u00ff\\d-_']*)\\s?/g,\n    fragmentLink:   /\\[([^\\]]*)\\](?:#([A-z\\u00C0-\\u00ff\\d-_']+))?/g,\n    fragmentOpen:   /\\{(?:([A-z\\u00C0-\\u00ff\\d-_']+)\\:)?/g,\n    fragmentClose:  /\\}/g\n  },\n  tags: {\n    strikethrough:  /~~([^~]+?)~~/g,\n    bold:           /(?:\\*\\*|__)([^\\*]+?)(?:\\*\\*|__)/g,\n    italic:         /(?:\\*|_)([^\\*]+?)(?:\\*|_)/g,\n    image:          /!\\(([^\\)]*)\\)/g,\n    link:           /@([^\\(]+)\\((http(s)?:\\/\\/.*)\\)/g\n  }\n};\n\nconst safeStr = (str) => {\n  return (/^[0-9]+$/.test(str) || /^_/.test(str) ? '_' : '') +\n    _.kebabCase(_.deburr(_.escape(str)));\n}\n\nconst markup = (str) => _.escape(str)\n  .replace(regExps.tags.strikethrough, '<del>$1</del>')\n  .replace(regExps.tags.bold,          '<strong>$1</strong>')\n  .replace(regExps.tags.italic,        '<em>$1</em>')\n  .replace(regExps.tags.image,         '<img src=\"$1\" />')\n  .replace(regExps.tags.link,          '<a href=\"$2\" target=\"_blank\" class=\"external\">$1</a>');\n\nlet tokenizer = (source) => {\n\n  if (_.size(source.match(/\\{/)) != _.size(source.match(/\\}/)))\n    throw new SyntaxError(errorMessages.unmatchedCurlyBrackets);\n\n  source = [source];\n\n  source = _.map(_.compact(_.flatten(source)), (source) =>\n    source.split(regExps.elements.curlyBrackets));\n  source = _.map(_.compact(_.flatten(source)), (source) =>\n    source.split(regExps.elements.paragraph));\n  source = _.map(_.compact(_.flatten(source)), (source) =>\n    source.split(regExps.elements.fragmentLink));\n\n  return _.compact(_.flatten(source));\n\n}\n\nlet parser = (tokens) => {\n\n  let lastIds = [[]], level = 0;\n  let result = _.reduce(tokens, (output, token, i) => {\n\n    let matches = {};\n    _.each(_.clone(regExps.matches), (v, k) => {\n      v.lastIndex = 0; matches[k] = v.exec(token);\n    });\n\n    if (matches.paragraph) {\n\n      if (level > 0)\n        throw new SyntaxError(errorMessages.paragraphInFragment);\n\n      let openedBy = matches.paragraph[1]\n        ? ` data-opened-by=\"${ safeStr(matches.paragraph[1]) }\"` : '';\n      output += `</p><p${ openedBy }>`;\n\n    } else if (matches.fragmentOpen) {\n\n      let id = matches.fragmentOpen[1]\n        ? safeStr(matches.fragmentOpen[1]) : _.first(_.last(lastIds));\n\n      lastIds[_.size(lastIds) - 1].shift();\n      output += `<span data-opened-by=\"${ id || '_nothing' }\">`;\n      lastIds.push([]);\n      level++;\n\n    } else if (matches.fragmentClose) {\n\n      output += `</span>`;\n      lastIds.pop();\n      level--;\n\n    } else if (matches.fragmentLink) {\n\n      let id;\n      if (matches.fragmentLink[2]) {\n        id = safeStr(matches.fragmentLink[2])\n      } else {\n        id = _.uniqueId(); lastIds[lastIds.length - 1].push(id);\n      }\n\n      output += `<a href=\"#\" data-opens=\"${ id }\">${ matches.fragmentLink[1] }</a>`;\n\n    } else {\n\n      output += markup(token);\n\n    }\n\n    return output;\n\n  }, '');\n\n  return `<p>${ result }</p>`;\n\n}\n\nfunction RussianDoll (source) {\n\n  if (!_.isString(source))\n    throw new TypeError(errorMessages.sourceMustBeString);\n\n  this.source = source;\n  this.tokens = tokenizer(this.source);\n  this.html   = parser(this.tokens);\n\n}\n",null],"sourceRoot":"/source/"}